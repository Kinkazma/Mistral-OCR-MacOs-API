import Foundation

struct OCRResult {
    let outputText: String
    let outputFileURL: URL?
    let pages: Int
}

final class OCRClient {
    static let shared = OCRClient()
    
    func process(normalized: NormalizedInput, model: String, includeImages: Bool, outputKind: OutputKind) async throws -> OCRResult {
        let key = SettingsStore.shared.apiKey
        guard !key.isEmpty else { throw NSError(domain: "ocr", code: -1, userInfo: [NSLocalizedDescriptionKey: "API key missing"]) }
        struct Doc: Encodable {
            let type: String
            let document_url: String?
            let image_url: String?
        }
        struct Request: Encodable {
            let model: String
            let document: Doc
            let include_image_base64: Bool
        }
        // Load the file content into memory.  If the normalized input refers
        // to a temporary converted file (e.g. a PNG or PDF generated from
        // another format), we will remove it after reading to avoid leaving
        // orphaned artifacts in the temporary directory.
        let bytes = try Data(contentsOf: normalized.url)
        // Capture the path now because we may remove the file below
        let normalizedPath = normalized.url.path
        let b64 = bytes.base64EncodedString()
        let mime = normalized.mime
        
        let doc: Doc
        switch normalized.kind {
        case .documentURL:
            doc = Doc(type: "document_url", document_url: "data:\(mime);base64,\(b64)", image_url: nil)
        case .imageURL:
            doc = Doc(type: "image_url", document_url: nil, image_url: "data:\(mime);base64,\(b64)")
        }
        let reqBody = Request(model: model, document: doc, include_image_base64: includeImages)
        
        var req = URLRequest(url: URL(string: "https://api.mistral.ai/v1/ocr")!)
        req.httpMethod = "POST"
        req.addValue("application/json", forHTTPHeaderField: "Content-Type")
        req.addValue("Bearer " + key, forHTTPHeaderField: "Authorization")
        req.httpBody = try JSONEncoder().encode(reqBody)
        
        let (data, resp) = try await URLSession.shared.data(for: req)
        guard (resp as? HTTPURLResponse)?.statusCode == 200 else {
            let err = String(data: data, encoding: .utf8) ?? "HTTP error"
            throw NSError(domain: "ocr", code: (resp as? HTTPURLResponse)?.statusCode ?? -1, userInfo: [NSLocalizedDescriptionKey: err])
        }
        let decoded = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        let pages = (decoded?["pages"] as? [[String: Any]]) ?? []
        let md = pages.compactMap { $0["markdown"] as? String }.joined(separator: "\n\n")
        
        
        // Write markdown to export folder
        let fm = FileManager.default
        let folder = SettingsStore.shared.exportFolder
        try? fm.createDirectory(at: folder, withIntermediateDirectories: true)
        let filename = "OCR_\(UUID().uuidString).md"
        let outURL = folder.appendingPathComponent(filename)
        try? md.data(using: .utf8)?.write(to: outURL)
        // If the normalized file resides inside the system temporary directory
        // (`NSTemporaryDirectory()`), delete it now.  This prevents
        // accumulation of converted PDFs/PNGs generated by FormatDetect.normalize().
        let tmpDir = FileManager.default.temporaryDirectory.path
        if normalizedPath.hasPrefix(tmpDir) {
            try? FileManager.default.removeItem(atPath: normalizedPath)
        }
        return OCRResult(outputText: md, outputFileURL: outURL, pages: pages.count)

    }
}
